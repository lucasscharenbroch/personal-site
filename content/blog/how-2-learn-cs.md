---
title: "HOW-2 Learn CS"
subtitle: "A Noob Tutorial (how I would start again from scratch)"
date: 2024-05-24T18:07:06-05:00
notability: 6
tags: ["Learning", "Tutorial"]
draft: true
---

There is no "shortest path" to programming expertise.
The only way to achive true skill is through the grind: putting in many hours solving a vast selection of challenges.
It's useless trying to describe the details of the girnd, as most of the details are unimportant.
Grind is necessary, but topic of the grind isn't critical.

I *do* think there is a "shortest path" to learning the *fundamentals* of CS, though, or at least it's a subject worth trying to optimize.
There are a handful of well-defined core topics that are useful to learn as a general foundation for software development.
I've spent a whlie studying these, and I've found a few excellent resources.

---

- this is basically a guide to self-taught for traditional cs concepts
- mostly useful for a hollistic knowledge, or getting ahead on a degree
- how I would do it again
- presents a "minimal path": there is no such thing, and there is, by necessity inefficiency, but *the reader should choose their own* (preferably smething they're excited about): I'll present the baseline and try to minimize nonsense

- bootstrapping (learning something from nothing) (python)
- web fundamentals (html+js+css)
- low-level (C (K&R), a teaspoon of ASM and hardware)
- DSA (leetcode, 6.006)
- Tooling (Shell (linux pocket guide) + GNU Coreutils, git, vim (when you're bored))

The rest is pretty unimportant: make projects, aim for volume and variation.
Here are some ideas:

(easier earlier on):
- web dev (frameworks, static sites, typescript)
- learn new languages (derek banas tutorial, learn X in Y, read [shortest] doc book, lazy-learn), write projects in those language
- work with existing tooling and libraries

(slightly harder):
- do more systems-y stuff
- full-stack (+all the tooling)

(probably wait)
- Contribute to Open-Source
- Built large-scale programs (this bullet primarily implies that other projects should aim low: it's useful to build big projects, but not feasible early on. This is generally self-enforcing, but being aware of it might make planning easier)
