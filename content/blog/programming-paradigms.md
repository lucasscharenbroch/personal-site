---
title: "Programming Paradigms"
subtitle: "Why it's practical to learn a variety of languages"
notability: 7
tags: ["PL", "FP"]
date: 2024-05-26T10:03:14-06:00
draft: true
---

## Ideas and Code

Writing code is a never-ending battle to translate abstract ideas into formal instructions.
This translation is lossy by nature: by making our ideas concrete, we are forced to face their inherent complexity, and the bewilderingly large set of ways to arrange their inner-workings.

Programming is ultimately about coping with this complexity, often by imposing extra constraints, for example:

- Programming Language Syntax
- Style/Structural Conventions
- Idioms
- Design Patterns

The goal is for these rules to narrow the scope of possible translations, reducing the likelihood of out-of-control complexity.
However, the rules aren't perfect, and they almost always leave something to be desired.
This framework for expression of ideas is all too often at odds with the ideas themselves.
Furthermore, the framework iteslf can have unintentional influence on the ideas: as a programmer becomes more comfortable with a translation method, it becomes increasingly harder to draw the line between the ideas and their translations.

This is why I (like so many others) am so interested in trying to deeply understand less-popular programming paradigms[^fun-to-learn].
My goal is to train myself to deeply understand the formulation of ideas by analyzing their translations through a variety of constraint-sets.

[^fun-to-learn]: They're also a lot of fun to learn.

---

- on learning langauge, cont.
    - a hidden necessity for maturity
    - it isn't so obvious from up close, but look at the extremes:
        - the 30-year cobol developer who doesn't know what JS is
        - the FP enthusiast who swears by haskell and scorns all industrial programming and soydevery
        - the astronomer who solely uses python
        - the soydev who refuses to use a language that doesn't end in the word "script"
    - what's the problem here?
        - lack of exposure, lack of multi-POV and nuanced opinion: they are forced to think in a rigid way
        - when we move away from the extremes, this becomes less obvious, but it still remains a weakness
        - these devs can probably perform pretty well in their resp. neeshes (and that's perfectly acceptable if that's what they want), but if they hope to have general programming ability and to be able to write whatever program they want, then they're seriously handicapped
