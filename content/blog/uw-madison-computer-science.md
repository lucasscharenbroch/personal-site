---
title: "UW Madison Computer Science"
subtitle: "An overview of classes and resources"
notability: 7
tags: ["College"]
date: 2023-07-01T17:41:21-05:00
---

I like to plan things out, especially things of high importance. Since college happens to fall into that category, I've spent a significant amount of time planning out courses, and I've made a habit of studying for every math/cs course *before* the class begins. I was able to do both of these things with the help of online resources, many of which were student-created. I intend for this post to serve as an overview of the degree requirements and my experience with the classes for anybody who may be interested in what the degree entails or how to go about it. My main focus is the Computer Science major, but there is some overlap with general degree requirements.

## General Resources
- [Official CS Requirements (BS)](https://guide.wisc.edu/undergraduate/letters-science/computer-sciences/computer-sciences-bs/#requirementstext) &mdash; BS and BA are almost the same, except for general requirements.
- [Public Course Search & Enroll](https://public.enroll.wisc.edu/search) &mdash; Central site for class availability and enrollment.
- [Noguera's Course Map](https://www.noguera.dev/course-map/) &mdash; Great visualization of CS course dependencies.
- [UW Discord Server](https://discord.com/college) &mdash; A center for classes, clubs, and general banter.
- [Rui Pan's Course Guide](https://ruipan.xyz/wisc_courses.html) &mdash; Similar to this post.
- [UPL](https://www.upl.cs.wisc.edu) &mdash; The UPL has a course night every semester; see their discord server for slides.
- [David Teather's CS 500+ Tier List](https://dteather.com/blogs/madison-class-rankings/) &mdash; Includes fine-grained class info as well (topics, hw format)
- [Nico Salm's Class Tier List](https://nicosalm.io/blog/uw_class_tierlist/) &mdash; "Coming Soon"

## Requirement Clarifications
The university lays things out pretty well, but there are some small ambiguities due to the non-programatic definition of the requirements. It turns out that [DARS](https://registrar.wisc.edu/dars/) is the soultion to this issue (you can find it more details in Course Search and Enroll and Noguera's page (see above)), but here are a few clarifications that I was initially uncetain of.

- Any subset of degree requirement from the set {General Education (Quantatative Reasoning A and B, Communication A and B, Ethnic Studies), Breadth (Natural/Physical/Biological Science, Literature, etc.), Difficulty (Intermediate/Advanced), Other Degree Requirement (for CS: Theory of CS, Software/Hardware, Applications, Electives, etc.)} can be fulfilled by a single course, but no element in the set can be fufilled *more than once* by a single course, unless that course can be taken multiple times for credit (in which case it can count towards each requirement once per time taken).
- Literature is a subset of Humanities: all Literature-Breadth courses also count for Humanities Breadth (a class taken for Literature credit also counts for Humanities, despite the above rule).
- Retroactive credits are *only* earned with a B or higher.
- The Summer Session credit limit rule applies on a per-session-basis: i.e. "no more than x credits in an x-week session" implies (assuming x is the 8-week session DHH) "no more than 8 credits in DHH". This doesn't add any restrictions on sessions that may overlap with DHH, despite the average credit per week potentially exceeding 1 credit.
- "In-Residence" doesn't literally imply "Living in Madison". Online classes through UW count as "In-Residence".

## The Plan

My goal is to graduate in as few semesters as possible.
This is for three main reasons:
(1) The standard lecture/discussion/homework/exam format of college rarely aligns well with my desired pace/focus.
(2) I like pushing the limits: the rewards of my efforts seem to be proportional to the amount of work I put in, so I refuse to purposely hold back.
(3) College is expensive. We could go into the details, but you probably get the point.

I think that this reasoning is relatively straightforward and probably relatable for a lot of people, but my advisor refused to even discuss a 2-year plan, repeatedly insisting that I rethink my plan, or else my mental health and networking opportunities were at stake. I bring this up to point out that my advisor was not entirely wrong: such a plan *is not* fit for everybody, and there are certainly *some* opportunities that will be missed by graduating early. At the same time, I think it's closed-minded to assume that such a plan is not fit for *any* student, and that the opportunities gained by graduating later necessarily outweigh the cost (namely the financial vulnerability) incurred by extra semesters. I am not an extraordinary student, but I did put a considerable amount of work in to prepare for classes and study CS in general. I encourage anybody considering early graduation to consider the opportunity costs of *all* of the options, and to avoid underestimating their own abilities.

### AP Credits
- Math 221 &mdash; Calculus AB (5I)
- Econ 101 &mdash; Microeconomics (4E) [Social Studies]
- Econ 102 &mdash; Macroeconomics (4E) [Social Studies]
- History X13 &mdash; US History (3E)
- History X13 &mdash; World History (3E)
- English X04 &mdash; Language and Composition (3E)
- Political Science 104 &mdash; Government and Politics (4E) [Social Studies]

### Fall 2022
- CS 300 &mdash; Programming II (3I) [CS Req.]
- Math 222 &mdash; Calculus & Analytic Geometry 2 (4I) [CS Req.]
- Spanish 204 &mdash; Fourth Semester Spanish (4I + (4I + 8E) (retro)) [Forth Unit of Foreign Language]
- ILS 203 &mdash; Western Culture: Literature & The Arts 1 (3E) [Literature]
- Music 43 &mdash; University Band (1E)
- Music 113 &mdash; Music in Performance (Clap for Credit) (1E) [Humanities]

### Spring 2023
- CS 252 &mdash; Intro to Computer Engineering (3E) [CS Req.]
- CS 400 &mdash; Programming III (3I) [CS Req.]
- CS 368 &mdash; Learn a Programming Language: Python (1I)
- Math 340 &mdash; Elementary Matrix & Linear Algebra (3A) [Math Elective 1/2]
- Math 240 &mdash; Intro to Discrete Math (3I) [CS Req.]
- Music 102 &mdash; Jazz in 20th-Century America (3E) [Ethnic Studies]
- Music 43 &mdash; University Band (1E)
- Music 113 &mdash; Music in Performance (Clap for Credit) (1E) [Humanities]

### Summer 2023
- CS 577 &mdash; Intro to Algorithms (4A) [Theory of CS 1/1]
- CS 540 &mdash; Intro to Artificial Intelligence (3A) [CS Applications 1/1]
- CS 435 &mdash; Intro to Cryptography (3A) [Math elective 2/2]
- AAE 335 &mdash; Intro to Data Analysis (2E)

### Fall 2023
- CS 559 &mdash; Computer Graphics (3I) [CS Electives 1/2]
- CS 542 &mdash; Intro to Software Security (3I) [Software and Hardware 1/2]
- CS 354 &mdash; Machine Organization & Programming (3I) [CS Req.]
- CS 502 &mdash; Theory and Practice in CS Education (1I)
- Astronomy 200 &mdash; The Physical Universe (3I) [Physical Science]
- Literaure in Translation 203 &mdash; 19th & 20th Century Russian Literature (4E) [Literature, Comm B]
- Music 43 &mdash; University Band (1E)

### Spring 2024 (enrolled)
- CS 536 &mdash; Intro to Programming Languages and Compilers (3A) [CS Electives 2/2]
- CS 538 &mdash; Intro to the Theory and Design of Programming Languages (3A) [Software and Hardware 2/2]
- CS 368 &mdash; Learn a Programming Language: C++ (1I)
- Nutritional Sciences 132 &mdash; Nutrition Today (3E) [Biological Science]
- Linguistics 101 &mdash; Human Language (3E)
- Music 151 &mdash; Basic Concepts of Music Theory (3E)
- Music 43 &mdash; University Band (1E)
- Music 113 &mdash; Music in Performance (Clap for Credit) (1E)

## CS Requirements
### CS 200 &mdash; Programming I
An intro to programming fundamentals and Java syntax. I tested out of CS200 with the [self-assessment](https://www.cs.wisc.edu/cs-200-300-placement-self-assessment/), so I can't speak about the class as a whole, but I did read through almost all of the [slides online](https://cs200-www.cs.wisc.edu/wp/wp-content/uploads/2018/), which essentially covered a subset [Java Tutorials](https://docs.oracle.com/javase/tutorial/java/index.html) (plus some more explanations of basic programming concepts and style guidelines), which I had read earlier in the summer. The self-assessment was consisted of a project ([peg solitaire](https://cs300-www.cs.wisc.edu/wp/peg-solitaire/), which was slightly easier than the average CS300 assignment), a short (30 question) sample CS200 final exam (which mainly covered basic syntax), and a "reflection".

### CS 300 &mdash; Programming II
An overview of [Object-Oriented Programming](https://en.wikipedia.org/wiki/Object-oriented_programming) and fundamental [Data Structures](https://en.wikipedia.org/wiki/Data_structure). Like 200, the [course slides](https://cs300-www.cs.wisc.edu/wp/wp-content/uploads/2018/) can be found online. The OOP portion is also almost completely overlapping with the Java Tutorials, but 300 also highlights a few more implementation details of how arrays and references work (i.e. heap vs stack), which are further iterated in 354. The Data Structures covered (linked lists, trees, heaps) are generally considered fundamental (they're asked about in a lot of [leetcode](https://leetcode.com/) problems), but aren't practically very useful, because they're implemented in most languages' standard libraries. The class itself consists of quizzes and exams (both in the same canvas-quiz format), programming assignments, as well as a mandatory online textbook through [zybooks](https://www.zybooks.com/) (a few other intro CS courses use zybooks as well; to earn the points, you must click through the readings and answer some basic "challenge" activities). The programming assignments involve fill-in-the-blank functionality (i.e. a method's documentation is given, and you must write it) and writing testers. While the programs aren't inherently complicated, there is a mandatory style guide, which requires the use of [javadoc](https://en.wikipedia.org/wiki/Javadoc) comments, which are (in my opinion) incredibly verbose (for the uses of this class); this, in combination with the verbose nature of Java itself, makes the programs much harder to work with.

### CS 400 &mdash; Programming III<a name="400"></a>
Sundries. This course attempts to cover lots of miscellaneous practical knowledge for programming (Bash, Git, Make, HTML/CSS/JS, Regex) along with a crossover between 300's tougher concepts and 577's easier concepts (Hash Maps, [Balanced BSTs](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree), Shortest Path, [Minimum Spanning Trees](https://en.wikipedia.org/wiki/Minimum_spanning_tree)), along with some more specialized Java tools and language features (JUnit, JavaFX, Lambda Expressions). Projects are done in groups of eight students (with two subgroups of four working on separate instances of the implementation), and serve as a way to practice all of the material (using the tools to work on projects related to the DSA concepts). There were also some weekly quizzes and activities sprinkled in to supplement the projects. The class was about as crazy as it sounds, but it worked surprisingly well. The projects were unsurprisingly messy, but considering the team aspect and the fact that the programs were completely designed by the teams (in comparison to the fill-in-the-blank methods of 200-300), I was impressed when our projects came together and worked as expected (almost).

### CS/Math 240 &mdash; Intro to Discrete Math
Basic Logic, Proof Techniques, Graph Theory, Set Theory, and Combinatorics. I took this class with the Math Department (Prof. Sobieska); I've heard that there were previously big differences between the Math and CS version, but this one seemed to mirror [Dieter's Notes](https://pages.cs.wisc.edu/~hasti/cs240/readings/) almost exactly, which are apparently the basis for the CS version. The class was laid out almost exactly like a typical math class, except that the textbook was through zybooks. Most of the material in this course is immediately relevant for 577 (the more popular of the two options for the Theory of CS requirement).

### CS 252 &mdash; Intro to Computer Engineering
Computation at the binary, transistor, logic-gate, machine-language, and assembly-language levels. The class began with binary representations of integers, then rapidly jumped abstractions, finishing with a description of the [LC3](https://en.wikipedia.org/wiki/Little_Computer_3) ("Little Computer 3") architecture. Having already read a [book](https://www.asmirvine.com/) on x86 assembly and worked on a [project (of sorts)](https://github.com/lucasscharenbroch/ASMUtilityLibrary) with it, the assembly and binary logic portions of this course seemed trivial. The quizzes and exams were identical to the homework (with slight differences), but they were auto-graded through canvas, so a single mistake often meant a ~5% deduction. As one might imagine, this was pretty cruel when working with (binary) machine code and bitwise operations.


### CS 354 &mdash; Machine Organization and Programming
Intro to [C](https://en.wikipedia.org/wiki/The_C_Programming_Language) and various low-level topics. Topics include heap allocation, caching, x86 assembly (AT&T), stack frames, signals, and linking; all of these are discussed at a very high level. A handful of projects interlace learning C with small toy-examples of the aforementioned topics. Like in 252, "homeworks" are actually timed quizzes, whose questions are very similar to exam-questions. The class spends little time focusing on the fundamentals of C (it's framed like a review); it's pretty much assumed that the student learns C on their own. Reading [K&R](https://en.wikipedia.org/wiki/The_C_Programming_Language) ([pdf](https://kremlin.cc/k&r.pdf)) is the recommended way of doing that.

## CS/Math Electives
### Math 340 &mdash; Elementary Matrix & Linear Algebra<a name="340"></a>
An introduction to the axioms of Linear Algebra. The first few weeks outlined relationships between linear systems and matrices, properties of matrices, matrix multiplication, and matrix inversion. The remainder of the course consisted mostly of memorizing a number of properties of matrices or vector-spaces that had implications on other properties of matrices (i.e. A is invertible <=> Ax = 0 has only the trivial solution <=> A is row (or column) equivalent to I[n] <=> the linear system Ax = b has a unique solution for every b in R^n <=> A is a product of elementary matrices <=> det(A) != 0 <=> the rank of A is n <=> the nullity of A is 0). I took this class at the same time as CS240, which was helpful because although there were no proofs in 340, there was some use of set theory and basic logic that wasn't completely explained. 340, unlike 341 (which requires Calc 3 as a prerequisite) is *not a proof-based class*: the professor and TAs made this very clear, and often used it as an excuse not to explain certain properties (whose simplest explanation would likely require a proof). It was kind of amusing hearing "this is not a proof-based class" as a slogan, but it certainly didn't make the material more intuitive, and as a result, the class consisted almost entirely of memorizing properties, which made the class easy, but not very interesting.

### CS 368 &mdash; Learn a Programming Language: Python
Zybooks for credit. There were weekly lectures, but attendance was work 5%, while the class was pass/fail (with 80% or above being a pass), and the other 95% was zybooks. In addition to the usual zybooks, there were "zybooks labs" at the end of each chapter, which were similar to leetcode easy problems, often with a few more implementation difficulties. The coverage of Python was in general quite rudimentary (the zybook was an intro-programming-with-Python book), but there were some useful topics covered (list comprehensions, advanced uses of f-strings, variadic functions, etc.).

### CS 577 &mdash; Intro to Algorithms
An overview of algorithmic paradigms. This class is commonly considered to be one of the most difficult "required" CS classes (520 is the only alternative to this class). It was significantly easier for me because of the large overlap with [ICPC](https://pages.cs.wisc.edu/~dieter/ICPC/), but learning paradigms, problem-solving, proofs, and examples at the same time makes for a hard class. I was lucky enough to find loads of class resources from a previous semester on the 577 Discord (Thanks, Fahim!), so I came into the class having watched all of the lectures and done all of the homework, so I was able to spend time in class reinforcing rather than of discovering. The final was still tough, though.

### CS 540 &mdash; Intro to Artificial Intelligence
Basic *mathematical* concepts involving AI. Depending on how you look at it, this class either opens up your eyes to the magical inner-workings of AI or takes all of the magic away because it turns out that it's just math. The only prerequisite is CS 300; this is most likely because requiring CS 240, Math 340, Math 234, and Stat 324 would be a little cruel, considering that 540 doesn't use more than a quarter of the material from any of them. Combining this with the inherent complexity behind many of the algorithms and formulas makes for a convoluted class with a lot of hand-waving and incomplete proofs. Luckily, the assessments usually stay out of the weeds. I took this class over an 8-week summer term with professor [Young Wu](https://pages.cs.wisc.edu/~yw), who set up the class in a way a little different from every other CS class I've taken (see [the course website](https://pages.cs.wisc.edu/~yw/CS540S23.html) for details).

### CS 435 &mdash; Intro to Cryptography
Overview and analysis of (mathematical) cryptographic algorithms. The course starts by outlining toy/historic/didactic ciphers involving shifts and permutations of the alphabet ([Caesar](https://en.wikipedia.org/wiki/Caesar_cipher), [Affine](https://en.wikipedia.org/wiki/Affine_cipher), [Vigen√©re](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher), [Playfair](https://en.wikipedia.org/wiki/Playfair_cipher), [General Substitution](https://en.wikipedia.org/wiki/Substitution_cipher)) and mathematical analysis of their security. This is followed by block and stream ciphers (with more formal mathematical definitions) and real-life algorithms involving them are discussed and analyzed ([Fistel](https://en.wikipedia.org/wiki/Feistel_cipher), [DES](https://en.wikipedia.org/wiki/Data_Encryption_Standard), [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)). The course ends with an outline of public-key cryptography ([ElGaml](https://en.wikipedia.org/wiki/ElGamal_encryption), [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)), [Rabin](https://en.wikipedia.org/wiki/Rabin_cryptosystem)). I took the course over the summer with David Zikel; the beginning of the course was nearly identical to Eric Bach's Cryptonotes (which may or may not still be available online), but the end of the course went farther into the gory (mathematical) details. The only prerequisite is linear algebra, but the course barely uses it at all (except for the Hill Cipher). Like 540, 435 brushes on a few areas (number theory, algorithms, probability, mathematical proofs, bitwise operations) of which knowledge would be useful, but it would be excessive to require any of them as a prerequisite.

### CS 542 &mdash; Software Security
A laundry-list of common software vulnerabilities, and how to address them. The course materials are [publicly available online](https://research.cs.wisc.edu/mist/SoftwareSecurityCourse/).
The majority of the topics in this course, once understood, are relatively elementary (they aren't technically challenging to understand), and there aren't many of them.
As a result, the majority of the course is recitation of ideas already discussed.
I'm usually not a fan of such repetition, but in the context of security, I agree with the approach, because of the gravity of the consequences of writing vulnerable code.
The primary difficulty of the class lies in the ability to work with a wide range of tools (the command line, web technologies, an assortment of programming languages, and various other tools), and to pick them up on the fly.
For that reason, for those preparing for this class, I'd recommend gaining a high-level understanding of C, Python, and Bash rather than reading through the course materials.

### CS 559 &mdash; Computer Graphics
A mix of mathematical and practical topics regarding the efficient drawing of 2d and 3d scenes. Hierarchical modeling, parametric curves, transformations, projections, the GPU graphics pipeline, and mathematical models for lighting are the main focuses. I took this class with Eftychios Sifakis (Efty), who uses a particularly obscure grading scheme: `total_grade = x * (sum_of_project_grades) + y * max(avg(midterm, final), final)`, where x and y aren't disclosed. Projects are graded out of 4, and obtaining a 3 is usually quite easy, but obtaining a 4 is a matter of creativity and originality. This framework is a little controversial because of the arbitrariness of how 3s and 4s are distributed (I agree with this critique: distribution *is not* and *cannot* be fair), but it gives the student more flexibility over their learning. Michael Gleicher is the other graphics professor at UW: his version of the course seems to be much more structured. Michael and Efty have historically made a lot of course material available publicly online ([Spring '23](https://pages.graphics.cs.wisc.edu/559-sp23/); [List of Terms](https://graphics.cs.wisc.edu/Courses/#559)).

### CS 502 &mdash; Theory and Practice in CS Education
An abstract guide to being a decent TA. Approximately 1 hour per week discussing personal opinions on high-level concepts with peers (discussion section), .25 hours reading/responding to various academic writings about tutoring, 1 hour on "the shelf" (the CS Learning Center), 1 hour in a "study group", and maybe 1 hour observing a TA/Peer Mentor in office hours. I think that this course has good intention, but it's not very effective. The theoretical portion of it was way too drawn out, repetitive, and obvious to maintain exigence (some of the insights are good, but the presentation didn't do them service). The practical part of the course was also ineffective, because nobody ever showed up to the CSLC or the study groups. Apparently the course is being reworked, so it will probably be in a different format in coming semesters.

### CS 536 &mdash; Intro to Programming Languages and Compilers
A (somewhat) practical intro to classic ideas in the space of compilers.
As far as I know, this course has not changed an ounce since the 90s.
The good part about this is that it contains all of the good ideas that were taught then;
the downside is that it's quite dry and the code for the projects is (in my humble opinion) awful.
I'm currently working on a blog post where I refactor the code from this class.
The topics are a mix of discrete-math-like ideas (FSMs, Lexing, Parsing) and low-level implementation details (Code Generation, Language Features, etc.).
[The course material is publicly available online](https://pages.cs.wisc.edu/~hasti/cs536/).
The central project is divided into 6 parts, dispensed across the semester;
the grade is entirely composed of projects (40%) and exams (60%).
The project is a reasonable amount of work considering how much of the grade it's worth.

### CS 538 &mdash; Intro to the Theory and Design of Programming Languages
Sundries under the large umbrella of PLs.
Kaiser, the professor who taught and designed the course (at the time I took it) is young and enthusiastic; he doesn't have the pretension of older and "more qualified" professors.
That being said, the courage has a lot of rough edges.
It gets very mathematical at times (with Lambda Calculus, Continuation-Passing-Style, Imperative Proofs, Haskell, etc.), yet also implementation-heavy (JavaScript, Closures, OOP).
Many important ideas are covered, but the experience as a whole is a little fragmented.
The 9 homeworks, 9 programming assignments, and 2 exams vary greatly in difficulty, and a handful are way harder then they ought to be, often because of needless ambiguity.
Some course material may be on [Kaiser's website](https://pister.dev/).
Overall, it's not a bad choice if you are interested in the subject.

### CS 368 &mdash; Learn a Programming Language: C++
A high-independence C++ workshop.
I took this with [Tyler](https://tyler.caraza-harter.com/), who was on leave at the beginning of the semester, so the 1-credit course was compressed into the second half of the semester.
The materials are publicly available on [his website](https://tyler.caraza-harter.com/cs368/s24/schedule.html).
It's 6 short (25-50 LoC) projects, plus some optional lectures.
Grading is pass-fail, and very forgiving.
The range of C++ covered is pretty narrow, but that's to be expected given the breadth of C++, and the most important ideas are mentioned.
